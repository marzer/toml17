#pragma once
#include "toml_common.h"

namespace TOML_NAMESPACE
{
	namespace impl
	{
		[[nodiscard]]
		constexpr bool is_whitespace(char32_t codepoint) noexcept
		{
			//see: https://en.wikipedia.org/wiki/Whitespace_character#Unicode
			//(characters that don't say "is a line-break")

			return codepoint == U'\t'
				|| codepoint == U' '
				|| codepoint == U'\u00A0' // no-break space
				|| codepoint == U'\u1680' // ogham space mark
				|| (codepoint >= U'\u2000' && codepoint <= U'\u200A') // em quad -> hair space
				|| codepoint == U'\u202F' // narrow no-break space
				|| codepoint == U'\u205F' // medium mathematical space
				|| codepoint == U'\u3000' // ideographic space
			;
		}

		[[nodiscard]]
		constexpr bool is_line_break(char32_t codepoint) noexcept
		{
			//see https://en.wikipedia.org/wiki/Whitespace_character#Unicode
			//(characters that say "is a line-break")

			return (codepoint >= U'\n' && codepoint <= U'\r')
				|| codepoint == U'\u0085' // next line
				|| codepoint == U'\u2028' // line separator
				|| codepoint == U'\u2029' // paragraph separator
			;
		}

		[[nodiscard]] TOML_ALWAYS_INLINE
		constexpr bool is_string_delimiter(char32_t codepoint) noexcept
		{
			return codepoint == U'"'
				|| codepoint == U'\'';
		}

		[[nodiscard]] TOML_ALWAYS_INLINE
		constexpr bool is_ascii_letter(char32_t codepoint) noexcept
		{
			return (codepoint >= U'a' && codepoint <= U'z')
				|| (codepoint >= U'A' && codepoint <= U'Z');
		}

		#if TOML_STRICT

		[[nodiscard]] TOML_ALWAYS_INLINE
		constexpr bool is_letter(char32_t codepoint) noexcept
		{
			return is_ascii_letter(codepoint);
		}

		#else

		[[nodiscard]]
		constexpr bool is_letter(char32_t codepoint) noexcept
		{
			if (is_ascii_letter(codepoint))
				return true;

			// this code was generated by a script;
			// see /vs/generate_is_letter_ranges.py

			if (codepoint < U'\u00B5' || codepoint > U'\U0001E943')
				return false;

			switch (static_cast<uint32_t>(codepoint) / 512u)
			{
				case 0u: TOML_LIKELY
				{
					if (codepoint <= U'\u01BF')
					{
						return codepoint == U'\u00B5'
							|| (codepoint >= U'\u00C0' && codepoint <= U'\u00D6')
							|| (codepoint >= U'\u00D8' && codepoint <= U'\u00F6')
							|| (codepoint >= U'\u00F8' && codepoint <= U'\u01BA')
							|| (codepoint >= U'\u01BC' && codepoint <= U'\u01BF');
					}
					else
					{
						return (codepoint >= U'\u01C4' && codepoint <= U'\u01FF');
					}
					// total codepoints in chunk: 314
				}
				case 1u:
				{
					if (codepoint <= U'\u037D')
					{
						return (codepoint >= U'\u0200' && codepoint <= U'\u0293')
							|| (codepoint >= U'\u0295' && codepoint <= U'\u02AF')
							|| (codepoint >= U'\u0370' && codepoint <= U'\u0373')
							|| (codepoint >= U'\u0376' && codepoint <= U'\u0377')
							|| (codepoint >= U'\u037B' && codepoint <= U'\u037D');
					}
					else if (codepoint <= U'\u03A1')
					{
						return codepoint == U'\u037F'
							|| codepoint == U'\u0386'
							|| (codepoint >= U'\u0388' && codepoint <= U'\u038A')
							|| codepoint == U'\u038C'
							|| (codepoint >= U'\u038E' && codepoint <= U'\u03A1');
					}
					else
					{
						return (codepoint >= U'\u03A3' && codepoint <= U'\u03F5')
							|| (codepoint >= U'\u03F7' && codepoint <= U'\u03FF');
					}
					// total codepoints in chunk: 302
				}
				case 2u:
				{
					return (codepoint >= U'\u0400' && codepoint <= U'\u0481')
						|| (codepoint >= U'\u048A' && codepoint <= U'\u052F')
						|| (codepoint >= U'\u0531' && codepoint <= U'\u0556')
						|| (codepoint >= U'\u0560' && codepoint <= U'\u0588');
					// total codepoints in chunk: 375
				}
				case 8u:
				{
					return (codepoint >= U'\u10A0' && codepoint <= U'\u10C5')
						|| codepoint == U'\u10C7'
						|| codepoint == U'\u10CD'
						|| (codepoint >= U'\u10D0' && codepoint <= U'\u10FA')
						|| (codepoint >= U'\u10FD' && codepoint <= U'\u10FF');
					// total codepoints in chunk: 86
				}
				case 9u:
				{
					return (codepoint >= U'\u13A0' && codepoint <= U'\u13F5')
						|| (codepoint >= U'\u13F8' && codepoint <= U'\u13FD');
					// total codepoints in chunk: 92
				}
				case 14u:
				{
					if (codepoint <= U'\u1D77')
					{
						return (codepoint >= U'\u1C80' && codepoint <= U'\u1C88')
							|| (codepoint >= U'\u1C90' && codepoint <= U'\u1CBA')
							|| (codepoint >= U'\u1CBD' && codepoint <= U'\u1CBF')
							|| (codepoint >= U'\u1D00' && codepoint <= U'\u1D2B')
							|| (codepoint >= U'\u1D6B' && codepoint <= U'\u1D77');
					}
					else
					{
						return (codepoint >= U'\u1D79' && codepoint <= U'\u1D9A');
					}
					// total codepoints in chunk: 146
				}
				case 15u:
				{
					if (codepoint <= U'\u1F57')
					{
						return (codepoint >= U'\u1E00' && codepoint <= U'\u1F15')
							|| (codepoint >= U'\u1F18' && codepoint <= U'\u1F1D')
							|| (codepoint >= U'\u1F20' && codepoint <= U'\u1F45')
							|| (codepoint >= U'\u1F48' && codepoint <= U'\u1F4D')
							|| (codepoint >= U'\u1F50' && codepoint <= U'\u1F57');
					}
					else if (codepoint <= U'\u1FB4')
					{
						return codepoint == U'\u1F59'
							|| codepoint == U'\u1F5B'
							|| codepoint == U'\u1F5D'
							|| (codepoint >= U'\u1F5F' && codepoint <= U'\u1F7D')
							|| (codepoint >= U'\u1F80' && codepoint <= U'\u1FB4');
					}
					else if (codepoint <= U'\u1FD3')
					{
						return (codepoint >= U'\u1FB6' && codepoint <= U'\u1FBC')
							|| codepoint == U'\u1FBE'
							|| (codepoint >= U'\u1FC2' && codepoint <= U'\u1FC4')
							|| (codepoint >= U'\u1FC6' && codepoint <= U'\u1FCC')
							|| (codepoint >= U'\u1FD0' && codepoint <= U'\u1FD3');
					}
					else
					{
						return (codepoint >= U'\u1FD6' && codepoint <= U'\u1FDB')
							|| (codepoint >= U'\u1FE0' && codepoint <= U'\u1FEC')
							|| (codepoint >= U'\u1FF2' && codepoint <= U'\u1FF4')
							|| (codepoint >= U'\u1FF6' && codepoint <= U'\u1FFC');
					}
					// total codepoints in chunk: 474
				}
				case 16u:
				{
					if (codepoint <= U'\u211D')
					{
						return codepoint == U'\u2102'
							|| codepoint == U'\u2107'
							|| (codepoint >= U'\u210A' && codepoint <= U'\u2113')
							|| codepoint == U'\u2115'
							|| (codepoint >= U'\u2119' && codepoint <= U'\u211D');
					}
					else if (codepoint <= U'\u2134')
					{
						return codepoint == U'\u2124'
							|| codepoint == U'\u2126'
							|| codepoint == U'\u2128'
							|| (codepoint >= U'\u212A' && codepoint <= U'\u212D')
							|| (codepoint >= U'\u212F' && codepoint <= U'\u2134');
					}
					else
					{
						return codepoint == U'\u2139'
							|| (codepoint >= U'\u213C' && codepoint <= U'\u213F')
							|| (codepoint >= U'\u2145' && codepoint <= U'\u2149')
							|| codepoint == U'\u214E'
							|| (codepoint >= U'\u2183' && codepoint <= U'\u2184');
					}
					// total codepoints in chunk: 44
				}
				case 22u:
				{
					if (codepoint <= U'\u2CEE')
					{
						return (codepoint >= U'\u2C00' && codepoint <= U'\u2C2E')
							|| (codepoint >= U'\u2C30' && codepoint <= U'\u2C5E')
							|| (codepoint >= U'\u2C60' && codepoint <= U'\u2C7B')
							|| (codepoint >= U'\u2C7E' && codepoint <= U'\u2CE4')
							|| (codepoint >= U'\u2CEB' && codepoint <= U'\u2CEE');
					}
					else
					{
						return (codepoint >= U'\u2CF2' && codepoint <= U'\u2CF3')
							|| (codepoint >= U'\u2D00' && codepoint <= U'\u2D25')
							|| codepoint == U'\u2D27'
							|| codepoint == U'\u2D2D';
					}
					// total codepoints in chunk: 271
				}
				case 83u:
				{
					if (codepoint <= U'\uA78E')
					{
						return (codepoint >= U'\uA640' && codepoint <= U'\uA66D')
							|| (codepoint >= U'\uA680' && codepoint <= U'\uA69B')
							|| (codepoint >= U'\uA722' && codepoint <= U'\uA76F')
							|| (codepoint >= U'\uA771' && codepoint <= U'\uA787')
							|| (codepoint >= U'\uA78B' && codepoint <= U'\uA78E');
					}
					else
					{
						return (codepoint >= U'\uA790' && codepoint <= U'\uA7BF')
							|| (codepoint >= U'\uA7C2' && codepoint <= U'\uA7C6')
							|| codepoint == U'\uA7FA';
					}
					// total codepoints in chunk: 233
				}
				case 85u:
				{
					return (codepoint >= U'\uAB30' && codepoint <= U'\uAB5A')
						|| (codepoint >= U'\uAB60' && codepoint <= U'\uAB67')
						|| (codepoint >= U'\uAB70' && codepoint <= U'\uABBF');
					// total codepoints in chunk: 131
				}
				case 125u:
				{
					return (codepoint >= U'\uFB00' && codepoint <= U'\uFB06')
						|| (codepoint >= U'\uFB13' && codepoint <= U'\uFB17');
					// total codepoints in chunk: 12
				}
				case 127u:
				{
					return (codepoint >= U'\uFF21' && codepoint <= U'\uFF3A')
						|| (codepoint >= U'\uFF41' && codepoint <= U'\uFF5A');
					// total codepoints in chunk: 52
				}
				case 130u:
				{
					return (codepoint >= U'\U00010400' && codepoint <= U'\U0001044F')
						|| (codepoint >= U'\U000104B0' && codepoint <= U'\U000104D3')
						|| (codepoint >= U'\U000104D8' && codepoint <= U'\U000104FB');
					// total codepoints in chunk: 152
				}
				case 134u:
				{
					return (codepoint >= U'\U00010C80' && codepoint <= U'\U00010CB2')
						|| (codepoint >= U'\U00010CC0' && codepoint <= U'\U00010CF2');
					// total codepoints in chunk: 102
				}
				case 140u:
				{
					return (codepoint >= U'\U000118A0' && codepoint <= U'\U000118DF');
					// total codepoints in chunk: 64
				}
				case 183u:
				{
					return (codepoint >= U'\U00016E40' && codepoint <= U'\U00016E7F');
					// total codepoints in chunk: 64
				}
				case 234u:
				{
					if (codepoint <= U'\U0001D4A6')
					{
						return (codepoint >= U'\U0001D400' && codepoint <= U'\U0001D454')
							|| (codepoint >= U'\U0001D456' && codepoint <= U'\U0001D49C')
							|| (codepoint >= U'\U0001D49E' && codepoint <= U'\U0001D49F')
							|| codepoint == U'\U0001D4A2'
							|| (codepoint >= U'\U0001D4A5' && codepoint <= U'\U0001D4A6');
					}
					else if (codepoint <= U'\U0001D505')
					{
						return (codepoint >= U'\U0001D4A9' && codepoint <= U'\U0001D4AC')
							|| (codepoint >= U'\U0001D4AE' && codepoint <= U'\U0001D4B9')
							|| codepoint == U'\U0001D4BB'
							|| (codepoint >= U'\U0001D4BD' && codepoint <= U'\U0001D4C3')
							|| (codepoint >= U'\U0001D4C5' && codepoint <= U'\U0001D505');
					}
					else if (codepoint <= U'\U0001D53E')
					{
						return (codepoint >= U'\U0001D507' && codepoint <= U'\U0001D50A')
							|| (codepoint >= U'\U0001D50D' && codepoint <= U'\U0001D514')
							|| (codepoint >= U'\U0001D516' && codepoint <= U'\U0001D51C')
							|| (codepoint >= U'\U0001D51E' && codepoint <= U'\U0001D539')
							|| (codepoint >= U'\U0001D53B' && codepoint <= U'\U0001D53E');
					}
					else
					{
						return (codepoint >= U'\U0001D540' && codepoint <= U'\U0001D544')
							|| codepoint == U'\U0001D546'
							|| (codepoint >= U'\U0001D54A' && codepoint <= U'\U0001D550')
							|| (codepoint >= U'\U0001D552' && codepoint <= U'\U0001D5FF');
					}
					// total codepoints in chunk: 488
				}
				case 235u:
				{
					if (codepoint <= U'\U0001D714')
					{
						return (codepoint >= U'\U0001D600' && codepoint <= U'\U0001D6A5')
							|| (codepoint >= U'\U0001D6A8' && codepoint <= U'\U0001D6C0')
							|| (codepoint >= U'\U0001D6C2' && codepoint <= U'\U0001D6DA')
							|| (codepoint >= U'\U0001D6DC' && codepoint <= U'\U0001D6FA')
							|| (codepoint >= U'\U0001D6FC' && codepoint <= U'\U0001D714');
					}
					else if (codepoint <= U'\U0001D7A8')
					{
						return (codepoint >= U'\U0001D716' && codepoint <= U'\U0001D734')
							|| (codepoint >= U'\U0001D736' && codepoint <= U'\U0001D74E')
							|| (codepoint >= U'\U0001D750' && codepoint <= U'\U0001D76E')
							|| (codepoint >= U'\U0001D770' && codepoint <= U'\U0001D788')
							|| (codepoint >= U'\U0001D78A' && codepoint <= U'\U0001D7A8');
					}
					else
					{
						return (codepoint >= U'\U0001D7AA' && codepoint <= U'\U0001D7C2')
							|| (codepoint >= U'\U0001D7C4' && codepoint <= U'\U0001D7CB');
					}
					// total codepoints in chunk: 448
				}
				case 244u:
				{
					return (codepoint >= U'\U0001E900' && codepoint <= U'\U0001E943');
					// total codepoints in chunk: 68
				}
				default:
					return false;
					// total chunks: 20
			}
		}

		#endif

		[[nodiscard]] TOML_ALWAYS_INLINE
		constexpr bool is_decimal_digit(char32_t codepoint) noexcept
		{
			return (codepoint >= U'0' && codepoint <= U'9');
		}

		[[nodiscard]] TOML_ALWAYS_INLINE
		constexpr bool is_hex_digit(char32_t codepoint) noexcept
		{
			return (codepoint >= U'a' && codepoint <= U'f')
				|| (codepoint >= U'A' && codepoint <= U'F')
				|| is_decimal_digit(codepoint);
		}

		[[nodiscard]]
		constexpr uint32_t hex_digit_to_int(char32_t codepoint) noexcept
		{
			if (is_decimal_digit(codepoint))
				return static_cast<uint32_t>(codepoint - U'0');
			return 10u + static_cast<uint32_t>(codepoint - ((codepoint >= U'a' && codepoint <= U'f') ? U'a' : U'A'));
		}

		[[nodiscard]]
		constexpr bool is_bare_key_character(char32_t codepoint) noexcept
		{
			return is_letter(codepoint)
				|| is_decimal_digit(codepoint)
				|| codepoint == U'-'
				|| codepoint == U'_'
			;
		}

		[[nodiscard]]
		constexpr bool is_value_terminator(char32_t codepoint) noexcept
		{
			return is_line_break(codepoint)
				|| is_whitespace(codepoint)
				|| codepoint == U']'
				|| codepoint == U'}'
				|| codepoint == U','
				|| codepoint == U'#'
			;
		}

		// based on the decoder found here: http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
		struct utf8_decoder final
		{
			uint32_t state{};
			uint32_t codepoint{};

			static constexpr uint8_t state_table[]
			{
				0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
				0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
				0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
				0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
				1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
				7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
				8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,		2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
				10,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,		11,6,6,6,5,8,8,8,8,8,8,8,8,8,8,8,

				0,12,24,36,60,96,84,12,12,12,48,72,		12,12,12,12,12,12,12,12,12,12,12,12,
				12, 0,12,12,12,12,12, 0,12, 0,12,12,	12,24,12,12,12,12,12,24,12,24,12,12,
				12,12,12,12,12,12,12,24,12,12,12,12,	12,24,12,12,12,12,12,12,12,24,12,12,
				12,12,12,12,12,12,12,36,12,36,12,12,	12,36,12,12,12,12,12,36,12,36,12,12,
				12,36,12,12,12,12,12,12,12,12,12,12
			};

			[[nodiscard]]
			constexpr bool error() const noexcept
			{
				return state == 12u;
			}

			[[nodiscard]]
			constexpr bool has_code_point() const noexcept
			{
				return state == 0u;
			}

			constexpr void operator () (uint8_t byte) noexcept
			{
				TOML_ASSERT(!error());

				const auto type = state_table[byte];

				codepoint = has_code_point()
					? (0xFFu >> type) & byte
					: (byte & 0x3Fu) | (codepoint << 6);

				state = state_table[state + 256u + type];
			};
		};

		template <typename T>
		class utf8_byte_stream;

		template <typename CHAR>
		class utf8_byte_stream<std::basic_string_view<CHAR>> final
		{
			static_assert(sizeof(CHAR) == 1_sz);

			private:
				std::basic_string_view<CHAR> source;
				size_t position = {};

			public:
				explicit constexpr utf8_byte_stream(std::basic_string_view<CHAR> sv) noexcept
					: source{ sv }
				{
					if (source.length() >= 3_sz
						&& static_cast<uint8_t>(source[0]) == 0xEF_u8
						&& static_cast<uint8_t>(source[1]) == 0xBB_u8
						&& static_cast<uint8_t>(source[2]) == 0xBF_u8)
					{
						position += 3_sz;
					}
				}

				[[nodiscard]]
				constexpr bool eof() const noexcept
				{
					return position >= source.length();
				}

				[[nodiscard]]
				constexpr bool error() const noexcept
				{
					return false;
				}

				[[nodiscard]]
				constexpr uint8_t operator() () noexcept
				{
					return static_cast<uint8_t>(source[position++]);
				}
		};

		template <typename CHAR>
		class utf8_byte_stream<std::basic_istream<CHAR>> final
		{
			static_assert(sizeof(CHAR) == 1_sz);

			private:
				std::basic_istream<CHAR>* source;

			public:
				explicit utf8_byte_stream(std::basic_istream<CHAR>& stream) noexcept
					: source{ &stream }
				{
					if (*source)
					{
						static constexpr uint8_t bom[] {
							0xEF_u8,
							0xBB_u8,
							0xBF_u8
						};

						using stream_traits = typename std::remove_pointer_t<decltype(source)>::traits_type;
						const auto initial_pos = source->tellg();
						size_t bom_pos{};
						auto bom_char = source->get();
						while (*source && bom_char != stream_traits::eof && bom_char == bom[bom_pos])
						{
							bom_pos++;
							bom_char = source->get();
						}
						if (!(*source) || bom_pos < 3_sz)
							source->seekg(initial_pos);
					}
				}

				[[nodiscard]]
				bool eof() const noexcept
				{
					return source->eof();
				}

				[[nodiscard]]
				bool error() const noexcept
				{
					return !(*source);
				}

				[[nodiscard]]
				uint8_t operator() ()
				{
					return static_cast<uint8_t>(source->get());
				}
		};

		struct utf8_codepoint final
		{
			char32_t value;
			document_position position;
			uint8_t byte_count;
			uint8_t bytes[4];

			template <typename CHAR = string_char>
			[[nodiscard]] TOML_ALWAYS_INLINE
			std::basic_string_view<CHAR> as_view() const noexcept
			{
				static_assert(
					sizeof(CHAR) == 1,
					"The string view's underlying character type must be 1 byte in size."
				);

				return std::basic_string_view<CHAR>{ reinterpret_cast<const CHAR* const>(bytes), byte_count };
			}

			[[nodiscard]]
			constexpr operator char32_t& () noexcept
			{
				return value;
			}

			[[nodiscard]]
			constexpr operator const char32_t& () const noexcept
			{
				return value;
			}
		};
		static_assert(std::is_trivial_v<utf8_codepoint>);
		static_assert(std::is_standard_layout_v<utf8_codepoint>);

		struct TOML_INTERFACE utf8_reader_interface
		{
			[[nodiscard]]
			virtual const std::shared_ptr<const string>& source_path() const noexcept = 0;

			[[nodiscard]]
			virtual const utf8_codepoint* read_next() = 0;
		};

		template <typename T>
		class TOML_EMPTY_BASES utf8_reader final
			: public utf8_reader_interface
		{
			private:
				utf8_byte_stream<T> stream;
				utf8_decoder decoder;
				utf8_codepoint prev{}, current{};
				std::shared_ptr<const string> source_path_;

			public:

				template <typename U, typename STR = string_view>
				explicit utf8_reader(U && source, STR&& source_path = {})
					noexcept(std::is_nothrow_constructible_v<utf8_byte_stream<T>, U&&>)
					: stream{ std::forward<U>(source) }
				{
					current.position.line = 1_sz;
					current.position.column = 1_sz;

					if (!source_path.empty())
						source_path_ = std::make_shared<const string>(std::forward<STR>(source_path));
				}

				[[nodiscard]]
				const std::shared_ptr<const string>& source_path() const noexcept override
				{
					return source_path_;
				}

				[[nodiscard]]
				const utf8_codepoint* read_next() override
				{
					if (stream.eof())
						return nullptr;
					if (stream.error())
						throw parse_error{ "The underlying stream entered an error state"s, prev.position, source_path_ };
					if (decoder.error())
						throw parse_error{ "Encountered invalid utf-8 sequence"s, prev.position, source_path_ };

					while (true)
					{
						uint8_t nextByte;
						if constexpr (noexcept(stream()))
						{
							nextByte = stream();
						}
						else
						{
							try
							{
								nextByte = stream();
							}
							catch (const std::exception& exc)
							{
								throw parse_error{ exc.what(), prev.position, source_path_ };
							}
							catch (...)
							{
								throw parse_error{ "An unspecified error occurred"s, prev.position, source_path_ };
							}
						}
						if (stream.error())
							throw parse_error{ "The underlying stream entered an error state"s, prev.position, source_path_ };

						decoder(nextByte);
						if (decoder.error())
							throw parse_error{ "Encountered invalid utf-8 sequence"s, prev.position, source_path_ };

						current.bytes[current.byte_count++] = nextByte;
						if (decoder.has_code_point())
						{
							prev = current;
							prev.value = static_cast<char32_t>(decoder.codepoint);

							current.byte_count = {};
							current.position.index++;
							if (is_line_break(prev.value) && prev.value != U'\r')
							{
								current.position.line++;
								current.position.column = 1_sz;
							}
							else
								current.position.column++;

							return &prev;
						}

						if (stream.eof())
							throw parse_error{ "Encountered EOF during incomplete utf-8 code point sequence"s, prev.position, source_path_ };
					}
				}
		};

		template <typename CHAR>
		utf8_reader(std::basic_string_view<CHAR>, string_view) -> utf8_reader<std::basic_string_view<CHAR>>;

		template <typename CHAR>
		utf8_reader(std::basic_istream<CHAR>&, string_view) -> utf8_reader<std::basic_istream<CHAR>>;

		class TOML_EMPTY_BASES utf8_buffered_reader final
			: public utf8_reader_interface
		{
			private:
				utf8_reader_interface& reader;
				struct
				{
					static constexpr size_t capacity = 31; //+1 for the 'head' stored in the underlying reader
					utf8_codepoint buffer[capacity];
					size_t count = {}, first = {};
				}
				history;
				const utf8_codepoint* head = {};
				size_t negative_offset = {};

			public:

				explicit utf8_buffered_reader(utf8_reader_interface& reader_)
					: reader{ reader_ }
				{}

				[[nodiscard]]
				const std::shared_ptr<const string>& source_path() const noexcept override
				{
					return reader.source_path();
				}

				[[nodiscard]]
				const utf8_codepoint* read_next() override
				{
					if (negative_offset)
					{
						negative_offset--;

						// an entry negative offset of 1 just means "replay the current head"
						if (!negative_offset) 
							return head;

						// otherwise step back into the history buffer
						else
							return history.buffer + ((history.first + history.count - negative_offset) % history.capacity);
					}
					else
					{
						// first character read from stream
						if (!history.count && !head) TOML_UNLIKELY
							head = reader.read_next();

						// subsequent characters and not eof
						else if (head)
						{
							if (history.count < history.capacity) TOML_UNLIKELY
								history.buffer[history.count++] = *head;
							else
								history.buffer[(history.first++ + history.capacity) % history.capacity] = *head;

							head = reader.read_next();
						}

						return head;
					}
				}

				[[nodiscard]]
				const utf8_codepoint* step_back(size_t count) noexcept
				{
					TOML_ASSERT(history.count);
					TOML_ASSERT(negative_offset + count <= history.count);
					negative_offset += count;

					return negative_offset
						? history.buffer + ((history.first + history.count - negative_offset) % history.capacity)
						: head;
				}
		};
	}
}
