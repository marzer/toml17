#!/usr/bin/env python3

import sys
import re
import bs4 as soup
import requests
import traceback

def make_literal(codepoint):
	if (codepoint > 0xFFFF):
		return "U'\\U{:08X}'".format(codepoint)
	else:
		return "U'\\u{:04X}'".format(codepoint)
		
def add_range_to_chunks(chunk_size, chunks, first_codepoint, last_codepoint):
	start_chunk = int(first_codepoint / chunk_size)
	end_chunk = int(last_codepoint / chunk_size)
	for i in range(start_chunk, end_chunk+1):
		if (i not in chunks.keys()):
			chunks[i] = []
		chunks[i].append((
			max(first_codepoint, i * chunk_size),
			min(last_codepoint, ((i + 1) * chunk_size) - 1)
		))

def print_chunk_return(chunk, start, count, additional_indent=''):
	if (len(chunk) <= start):
		return
	print("\t\t{}return ".format(additional_indent), end='')
	for range_idx in range(start, min(len(chunk), start + count)):
		if (range_idx > start):
			print("\n\t\t\t{}|| ".format(additional_indent), end='')
		if (chunk[range_idx][0] == chunk[range_idx][1]):
			print("codepoint == {}".format(make_literal(chunk[range_idx][0])), end='')
		else:
			print("(codepoint >= {} && codepoint <= {})".format(make_literal(chunk[range_idx][0]), make_literal(chunk[range_idx][1])), end='')
	print(";")
	
def print_chunk_return_groups(chunk, ranges_per_group):
	if (len(chunk) <= ranges_per_group):
		print_chunk_return(chunk, 0, len(chunk))
		return
	group_count = int(len(chunk) / ranges_per_group) + (1 if (len(chunk) % ranges_per_group) > 0 else 0)
	for group_idx in range(0, group_count):
		first_idx = group_idx * ranges_per_group
		last_idx = min(ranges_per_group * (group_idx + 1), len(chunk)) - 1
		print("\t\t{}{}\n\t\t{{".format(
			'else ' if group_idx > 0 else '',
			'if (codepoint <= {})'.format(make_literal(chunk[last_idx][1])) if (group_idx + 1) < group_count else ''
		))
		print_chunk_return(chunk, first_idx, last_idx - first_idx + 1, "\t")
		print("\t\t}")
	

def main():
	re_title = re.compile(r"^.+'(.+?)'.+$")
	re_codepoint = re.compile(r'^U[+]([0-9a-fA-F]+)$')
	
	categories = (
		'LC', # cased
		'Ll', # lowercase
		#'Lm', # modifiers
		#'Lo', # other (huge category!)
		'Lt', # title case
		'Lu', # uppercase
	)

	# scrape for the codepoints from the chosen categories
	codepoints = []
	for category in categories:
		uri = 'https://www.fileformat.info/info/unicode/category/{}/list.htm'.format(category)
		response = requests.get(uri)		
		dom = soup.BeautifulSoup(response.text, 'html5lib')
		name = re_title.search(dom.body.find('h1').string).group(1)	
		character_list = dom.body.find('table', class_='table-list').tbody.find_all('tr')
		if (len(character_list) > 0):
			print("Adding {} characters from [{}] {}".format(len(character_list), category, name))
			for char in character_list:
				codepoint = int('0x{}'.format(re_codepoint.search(char.find('a').string).group(1)), 16)
				if (codepoint >= 128): # ASCII range is handled separately
					codepoints.append(codepoint)
	if (len(codepoints) == 0):
		return
	codepoints.sort()

	# divide the codepoints up into chunks of ranges
	chunk_size = 512
	chunks = {}
	first_codepoint = 0
	last_codepoint = 0
	for codepoint in codepoints:
		if (first_codepoint == 0):
			first_codepoint = codepoint
			last_codepoint = codepoint
		elif (last_codepoint == codepoint-1):
			last_codepoint = codepoint
		else:
			add_range_to_chunks(chunk_size, chunks, first_codepoint, last_codepoint)
			first_codepoint = codepoint
			last_codepoint = codepoint
	if (first_codepoint != 0):
		add_range_to_chunks(chunk_size, chunks, first_codepoint, last_codepoint)
	
	# emit the code to copy and paste into is_letter()
	print("\n// this code was generated by a script;\n// see /vs/generate_is_letter_ranges.py\n")
	print("if (codepoint < {} || codepoint > {})\n\treturn false;\n".format(
		make_literal(codepoints[0]),
		make_literal(codepoints[-1])
	))
	print("switch (static_cast<uint32_t>(codepoint) / {}u)\n{{\n".format(chunk_size), end='')
	for chunk_index, chunk in chunks.items():
		print("\tcase {}u:{}\n\t{{".format(
			chunk_index,
			' TOML_LIKELY' if chunk_index == 0 else ''
		))
		chunk_codepoints = 0
		for range in chunk:
			chunk_codepoints += (range[1] - range[0]) + 1
		print_chunk_return_groups(chunk, 5)
		print("\t\t// total codepoints in chunk: {}\n\t}}".format(chunk_codepoints))
	print("\tdefault:\n\t\treturn false;\n\t// total chunks: {}".format(len(chunks.keys())))
	print("\n}")
		

if __name__ == '__main__':
	try:
		main()
	except Exception as err:
		print('Fatal error: [{}] {}\n{}'.format(type(err).__name__, str(err), traceback.format_exc(err)), file=sys.stderr)
		sys.exit(1)
	sys.exit()
